                                Contents
                                1. Introduction 
                                2. Analysis 
                                         2.1. Why Computation 
                                         2.2. Stakeholders 
                                         2.3. Research 
                                                        2.3.1. Final Fantasy XIV 
                                                        2.3.2. Guild Wars 2 
                                                        2.3.3. Palia 
                                                        2.3.4. Spiritfarer 
                                                        2.3.5. Stardew Valley 
                                                        2.3.6. Ashes of Creation 
                                                        2.3.7. TODO: Path of Eternity 
                                                        2.3.8. TODO: Runescape 
                                         2.4. Essential Features 
                                         2.5. Limitations 
                                         2.6. Success Criteria 
                                         2.7. Requirements 
                                                        2.7.1. Hardware 
                                                        2.7.2. Software 
                                3. Design 
                                         3.1. Gameplay Loops 
                                                        3.1.1. Gathering 
                                                        3.1.2. Crafting 
                                                        3.1.3. Combat 
                                                        3.1.4. Trading 
                                4. Devlogs 
                                         4.1. 2023-03-05 - From Zero to Triangle 
                                                        4.1.1. Instances 
                                                        4.1.2. Physical Devices 
                                                        4.1.3. Surfaces 
                                                        4.1.4. Execution Model 
                                                        4.1.5. Devices and Queues 
                                         4.2. 2023-07-25 - Buffer Race Conditions 
                                                        4.2.1. The Problem 
                                                        4.2.2. Debugging 
                                                        4.2.3. The Fix 
                                         4.3. 2023-08-02 - Client Server Representation 
                                1.Introduction
                                MMOs (massively multiplayer online games) are a genre of video games
                                focusing on connecting thousands of players in one central shared
                                world where all players can interact and affect each other’s
                                experiences. Games from this genre include World of Warcraft,
                                RuneScape, Final Fantasy XIV, Guild Wars 2 and many more, many of
                                these games however were released around a decade ago and don’t take
                                advantage of modern computing. Furthermore, many of these games
                                struggle to stay relevant, especially to younger audiences due to
                                the outdated graphics and systems. My project is a game that hopes
                                to explore what a possible MMORPG taking advantage of modern
                                technologies could look like, focusing on immersion, simulation and
                                player interaction.
                                2.Analysis
                                2.1. Why Computation
                                Computers are well suited to MMO servers as they can simulate a
                                world with thousands of players in real-time while generating
                                content for players to explore, a human wouldn’t be able to keep up
                                with so many individuals at once. Computers are also well suited for
                                MMO clients as modern computer graphics can render realistic
                                environments real-time. In addition computers are good at
                                communicating with each other quickly and from long distances which
                                is a needed feature of an MMO client otherwise it cannot talk to the
                                server, humans are too slow at communication for it to be efficient
                                on a large scale.
                                2.2. Stakeholders
                                The main stakeholders for my game would be the players as they are
                                the target audience. This group can be split into two main
                                demographics: people who are new to MMOs, and those who are coming
                                from an existing MMO. To deal with this range of experience levels,
                                I will need to make sure there is a good set of tutorials to make
                                sure players new to the genre can understand the game. For gamers
                                more experienced with MMOs, I will need to look at existing games
                                and implement similar feature sets that these players will be
                                expecting, while still adding something new to the game to make it
                                stand out. I’ll also need to be considering both casual and
                                competitive players, and make mechanics and content to keep both
                                happy.
                                To get a representative sample for each demographic, I will be
                                talking to people from varying experience ranges with the genre. In
                                addition I will be sending out testing samples throughout the
                                development process, asking both groups for feedback.
                                2.3. Research
                                2.3.1.Final Fantasy XIV
                                Final Fantasy XIV(FFXIV) is an MMORPG released by Square Enix in
                                2010. The game revolves around its single-player story which is
                                mainly comprised of voice-acted cutscenes with various NPC
                                characters. The story unlocks most of the other mechanics in the
                                game such as gathering and crafting, dungeons, raids and mounts.
                                Gathering and crafting in FFXIV is unique thanks to its systems:
                                players are given a series of abilities that either increase
                                Progression, Quality, or increase the potential of other abilities.
                                Once Progression reaches 100% the item is gathered/ crafted, the
                                Quality value at this time determines the item’s chance to be High
                                Quality, meaning the item will be valued higher. This creates a fun
                                minigame for gathering and crafting which helps to disrupt the
                                monotony of many video game gathering/ crafting systems, this is
                                something I am hoping to replicate in my game.
                                2.3.2.Guild Wars 2
                                Guild Wars 2 is an MMORPG developed by ArenaNet in 2012, compared to
                                Final Fantasy XIV the game is much more open ended in its
                                progression, instead of a central story the player is given a level
                                which determines the content they can access, XP can be acquired
                                from many sources such as crafting, questing, PvP and exploration.
                                Guild Wars 2 has had three expansions added to it: Heart of Thorns,
                                Path of Fire and End of Dragons, each of these expansions have added
                                classes, specialisations, new chapters to the Living World and new
                                zones for players to explore. Heart of Thorns also changed the
                                progression system from level-based to the Mastery System. The
                                Mastery System is a huge tree of achievements, tasks and challenges
                                that each reward the player with items and Mastery Levels which can
                                be used like skill points in many games. This creates a completely
                                open ended, horizontal progression system that rewards players for
                                exploring the game while allowing them to pick and choose what
                                rewards they want, this is something I am hoping to base my game’s
                                progression on.
                                2.3.3.Palia
                                Palia is an unreleased MMO being developed by Singularity 6, it
                                focuses on providing a more casual, laid-back experience that many
                                other MMORPGs which can fixate on combat and a grand story when many
                                players just want to craft items for their house, farm crops and
                                trade with their friends. Not much has been released about Palia
                                yet, but I would like to try and incorporate this focus on more
                                casual features into the final game.
                                2.3.4.Spiritfarer
                                Spiritfarer is an 2-player indie RPG developed by Thunder Lotus
                                Games. Its a game about running a boat for spirits to live on while
                                they prepare to move on into the afterlife, the core gameplay is
                                about making sure these spirits are happy, well-fed and housed by
                                gathering and crafting materials to be used for the construction of
                                the boat. While the story is fantastic, its not something I am
                                planning to focus on. The part that interests me is the minigames,
                                there’s one for foraging, mining, smithing, smelting, cutting down
                                trees, weaving, cooking and more, each of these minigames are fun
                                and engaging and your performance in the minigame determines the
                                yield of the output, if your timing is off when your cutting a tree,
                                you’ll get less wood, if you time a pickaxe swing badly, you’ll get
                                less ore, etc. Spiritfarer is going to be main inspiration for
                                minigames for otherwise tedious mechanics.
                                2.3.5.Stardew Valley
                                Stardew Valley made by ConcernedApe presents itself as a basic indie
                                farming game, and while the farming part of the game is great, the
                                part where it is really fantastic is making the player feel like
                                they are part of the game world. The village throws festivals, has
                                birthday parties for the NPCs and as the player becomes friendlier
                                with the villagers they start getting invited to these events, they
                                get integrated into the village and made to feel at home. This
                                personal connection with the player is what many feel Stardew Valley
                                is all about, and something I would like to try and emulate in the
                                final game.
                                2.3.6.Ashes of Creation
                                Ashes of Creation is an unreleased MMORPG being developed by
                                Intrepid Studios. It is focusing on making a dynamic world where
                                player actions result in huge changes to the game’s world. The world
                                is split up into areas called nodes, eazch node has a development
                                level which determines the type and level of buildings players are
                                allowed to build in a city. Nodes also have abundances of certain
                                resources and scarcity of others, for example one node may have a
                                surplus of food but lack ore, so must trade with another nearby node
                                for those resources to keep its economy alive. Events like this are
                                called emergent gameplay as they emerged from other mechanics the
                                game developers designed, rather than being designed directly. This
                                emergent gameplay is something I am looking to achieve in the final
                                game.
                                2.3.7.TODO: Path of Eternity
                                2.3.8.TODO: Runescape
                                2.4. Essential Features
                                2.5. Limitations
                                Due to limitations in time and budget, the game will not target
                                smartphones or consoles, nor macOS as I don’t own a Mac, however
                                both Windows and Linux should be supported. In addition, I’m not
                                great at art, so I will use a simplistic, low-poly style so the
                                assets are simpler to create, I’m also hoping to use music licenced
                                under Creative Commons so I can avoid making my own, I’m more
                                interesting in the game design and programming.
                                Also due to the goal of making the game run on as many devices as
                                possible, I’m not going to be able to expect cutting-edge hardware,
                                the game will need to be performant and optimised for older
                                machines, my test for this will be my 6 year old laptop.
                                Finally I don’t have a large budget for servers, so the server code
                                needs to be well optimised and efficient so it can run on a machine
                                like a Raspberry Pi.
                                2.6. Success Criteria
                                To succeed my game will need to:
                                • Run on as many devices as possible
                                • Have low-latency, reliable networking
                                • Have intuitive, fun mechanics and UI
                                • Value the players time
                                • Have many mechanics to allow players to play the parts they enjoy
                                     while interacting with the rest of the world resulting in emergent
                                     gameplay
                                • Have an immersive world-wide story delivered through events and
                                     cutscenes
                                Many of these criteria are very subjective, so there will be phases
                                of playtesting with stakeholders during development where the
                                stakeholders get to play the game for a while and will evaluate it
                                against this criteria. I will also be evaluating against this
                                criteria when designing mechanics and systems.
                                2.7. Requirements
                                2.7.1.Hardware
                                • A computer with standard peripherals like keyboard, mouse/
                                     trackpad, etc
                                • A GPU capable of running Vulkan, this is mainly driver dependant
                                     unless the GPU is 10+ years old
                                • More concrete requirements will be decided when the game is closer
                                     to completion
                                2.7.2.Software
                                Because the game needs to be able to run on as many devices as
                                possible, I’ve tried to keep the requirements as basic as possible:
                                • Up-to-date graphics driver will be needed as I’ll be using modern
                                     graphics APIs like Vulkan
                                • Windows 10 or Linux
                                3.Design
                                3.1. Gameplay Loops
                                The majority of the game can be split into different gameplay loops:
                                3.1.1.Gathering
                                The gathering system will be responsible for the collection of most
                                resources for crafting and trading, from wood to ores to passive
                                monster drops.
                                3.1.2.Crafting
                                3.1.3.Combat
                                3.1.4.Trading
                                4.Devlogs
                                4.1. 2023-03-05 - From Zero to Triangle
                                Since I’ll be rolling my own engine to get the most out of older
                                computers, I need to build the systems a game engine would normally
                                provide. I decided to start development with the renderer, as I felt
                                it was going to be the most complicated of the engine systems, and
                                being able to show things on screen will make future development
                                easier to debug. Before starting there were a couple design
                                decisions I needed to make, such as whether to do the rendering on
                                the CPU or GPU.
                                     Option                                         Advantages                                                                   Disadvantages
                                                                                                                                                                 • Doesn’t take
                                                                                                                                                                      advantage of a
                                                                                    • No need for a complex
                                                                                                                                                                      coprocessor designed
                                                                                         graphics API
                                     CPU rendering                                                                                                                    for graphics
                                                                                    • No cross-processor
                                                                                                                                                                 • Limits CPU time
                                                                                         data transfer
                                                                                                                                                                      available for non-
                                                                                                                                                                      graphics tasks
                                                                                    • Often faster than CPU
                                                                                         rendering
                                                                                    • Means the CPU has                                                          • Complex APIs
                                     GPU rendering                                       more time to do other                                                   • Cross-processor data
                                                                                         tasks                                                                        transfer is slow
                                                                                    • Data is always
                                                                                         accessible
                                I decided on GPU rendering despite the extra complexity, as it moves
                                a lot of the work to a coprocessor which will lower the CPU
                                requirements as it will have more time to process other systems such
                                as UI and networking. GPU rendering would also allow me to be more
                                ambitious with the game’s graphics as it tends to be more powerful
                                for this than a CPU for this purpose. The downside to this decision
                                is that I’d have to learn a complex graphics API as well as a shader
                                language, which was my next decision.
                                     Option                       Advantages                                                                            Disadvantages
                                                                  • Most widely used                                                                    • Only works on Windows
                                                                       graphics API                                                                     • Also requires me to
                                     DirectX                      • Tends to be the best                                                                      learn a lot about the
                                                                       optimised due to its                                                                   Windows API
                                                                       wide use                                                                         • Fairly complex API
                                                                                                                                                        • Only work on MacOS
                                                                                                                                                        • Poorly documented
                                                                  • Only graphics API that
                                     Metal                                                                                                              • Forces you to use a
                                                                       MacOS natively supports
                                                                                                                                                              prioprietary shader
                                                                                                                                                              language
                                                                                                                                                        • Old API that tends to be
                                                                                                                                                              outperformed by newer
                                                                                                                                                              ones
                                                                                                                                                        • Uses a global context/
                                                                  • Simple API                                                                                state machine model that
                                                                  • Runs on Windows, MacOS,                                                                   makes it very hard to
                                     OpenGL
                                                                       Linux and some mobile                                                                  debug
                                                                       platforms                                                                        • A lot of behaviour in
                                                                                                                                                              other graphics APIs are
                                                                                                                                                              considered optional
                                                                                                                                                              extensions in OpenGL,
                                                                                                                                                              such as blending
                                                                  • Runs natively on
                                                                       Windows, Linux and some
                                                                       mobile platforms
                                                                  • Second-best optimised
                                                                       graphics API after
                                     Vulkan                            DirectX                                                                          • Very complex API
                                                                  • Runs non-natively on
                                                                       MacOS using MoltenVK
                                                                  • Wide array of extensions
                                                                       for things like hardware
                                                                       raytracing
                                With this research done and my goals of running on as many devices
                                as possible in mind, I decided to use Vulkan as it can be run on any
                                desktop platform and its well optimised, and also gives me the
                                oppotunity to explore recent graphics developments such as
                                raytracing. With that decided I found some online tutorials and
                                guides on Vulkan and started writing the graphics code.
                                Vulkan is written in C, and my program is written in Rust, which are
                                compatible using the Rust FFI(Foreign Function Interface), however
                                directly interfacing with C apis in Rust results in a lot of
                                boilerplate so I’d want to use an existing boilerplate library. I
                                chose one called ash which provided a minimal layer over the Vulkan
                                API, I chose it over a higher-level library such as vulkano because
                                I wanted the extra control over my graphics code.
                                4.1.1.Instances
                                One of the best parts of Vulkan is that there is no global state,
                                all shared data is handled with the VkInstance object. Creating a
                                 VkInstance object initialises the Vulkan API and allows the
                                application to pass information about itself to the implementation.
                                It also allows the application to pass in extensions and validations
                                layers that it plans to use.
                                Extensions are vulkan’s way of enabling features that not all GPU
                                manufacturers need to implement, such as raytracing, which wouldn’t
                                be needed in compute-focused GPUs such as the ones being used to
                                train AIs. The presentation system, which is responsible for
                                allowing a program to present images to the screen, is also behind
                                an extension as not all GPUs need to be able present to the screen,
                                because of this I will need to enable some extensions.
                                Vulkan is a very complex API and correct usage is difficult to
                                achieve without reading the 2000+ pages of documentation surrounding
                                it. Many APIs resolve this by adding computationally expensive
                                validation checks to ensure correct usage, but this has a lot of
                                overhead and makes assumptions on what to do when something goes
                                wrong. Khronos resolves these issues using what they call validation
                                layers, which are optional layers are inserted at instance creation
                                which intercept any API calls and log any issues with usage. Many
                                other comapnies have made validation layers such as LunarG who have
                                created a API dump layer which logs any API calls and their
                                parameters to the console for debugging. I’m planning to use
                                validation layers in my program to ensure valid usage of the vulkan
                                API, however I’ll only be enabling them when I’m debugging, so the
                                performance won’t be impacted for release builds of the game.
                                The final piece of information required to create the instance is
                                the application info, which includes the name and version of both
                                the game and engine as well as the minimum version of vulkan the
                                application will work with.
                                With extensions, validations layers and application info understood,
                                I had everything needed to write the code for instance creation, I
                                started with application info:
                                    1
                                           let app_info = vk::ApplicationInfo::builder()
                                    2
                                               .application_name(cstr!("aetheria"))
                                    3
                                               .application_version(vk::make_api_version(0, 1, 0, 0))
                                    4
                                               .engine_name(cstr!("aetheria"))
                                    5
                                               .engine_version(vk::make_api_version(0, 1, 0, 0))
                                    6
                                               .api_version(vk::make_api_version(0, 1, 3, 238));
                                The ash crate generates builder patterns for every structure in the
                                Vulkan API, which lets me replace struct initialisation with a
                                series of method calls, the ash create also uses to add some type
                                conversions between what I’m calling and what actually gets passed
                                to the Vulkan API, for instance here it allows me to pass a nicer
                                 &CStr for the application name rather than the actual field type
                                which is a *const c_char, a raw pointer. The cstr!("CONTENT") syntax
                                is a nice macro from the cstr create that lets me reduce some
                                boilerplate CStr initialisation code, it just creates a &'static CStr
                                with the contents of whatever string is passed into it. The calls to
                                 vk::make_api_version(::.) on lines 3, 5 and 6 are used because Vulkan
                                uses a strange version encoding to fit a variant, major, minor and
                                patch version (which are the arguments) into one 32 bit unsigned
                                integer, the make_api_version function just encodes the versions
                                correctly. I chose Vulkan 1.3.238 which at the time of writing was
                                the version installed on my computer, I chose the latest version as
                                I wanted all of the features available to me, once I finish the
                                graphics code I will likely come back here and reduce the version
                                number so more devices are supported.
                                Next I had to handle enabling extensions and validation layers, to
                                do this I first had to fetch a list of extensions and layers
                                supported by the implementation installed on the computer, this I
                                had to check that all the extensions and layers I wanted were
                                available, and if they were to enable them.
                                    1
                                             let available_layers = entry.enumerate_instance_layer_properties()?;
                                    2
                                             let available_extensions =
                                             entry.enumerate_instance_extension_properties(None)?;
                                    3
                                    4
                                             let available_layer_names: Vec<&CStr> = available_layers
                                    5
                                                 .iter()
                                    6
                                                 .map(|layer|
                                             CStr::from_bytes_until_nul(cast_slice(&layer.layer_name)).unwrap())
                                    7
                                                 .collect();
                                    8
                                    9
                                             let available_extension_names: Vec<&CStr> = available_extensions
                                    10
                                                 .iter()
                                    11
                                                 .map(|extension| {
                                    12
                                             CStr::from_bytes_until_nul(cast_slice(&extension.extension_name)).unwrap()
                                    13
                                                 })
                                    14
                                                 .collect();
                                    15
                                    16
                                             let wanted_layers = super::get_wanted_layers();
                                    17
                                             let wanted_extensions = get_wanted_extensions();
                                    18
                                    19
                                             let wanted_layers = super::intersection(&wanted_layers,
                                             &available_layer_names);
                                    20
                                             let wanted_extensions = super::intersection(&wanted_extensions,
                                             &available_extension_names);
                                    21
                                    22
                                             info!("Using instance layers: {:?}", wanted_layers);
                                    23
                                             info!("Using instance extensions: {:?}", wanted_extensions);
                                    24
                                    25
                                             let wanted_layers_raw: Vec<*const i8> =
                                    26
                                                 wanted_layers.iter().map(|name| name.as_ptr()).collect();
                                    27
                                             let wanted_extensions_raw: Vec<*const i8> =
                                    28
                                                 wanted_extensions.iter().map(|name| name.as_ptr()).collect();
                                Lines 1 and 2 call the Vulkan API to get a list of available layers
                                and extensions, lines 4-15 take the extension and layer information
                                get the names of each, turning them into &CStr objects. Then
                                 get_wanted_extensions and get_wanted_layers are called to get a static
                                list of names of wanted extensions/layers, the intersection of the
                                set of available extensions and the set of wanted extensions are
                                found, and then turned back into a list of Vec:*const i8> ready to be
                                passed back into the Vulkan API for instance creation. Currently my
                                wanted layers is just Khronos’ validation layer, and my wanted
                                extensions list is empty, since there are no extensions I want to
                                use yet.
                                The instance creation code is quite simply in comparison and just
                                takes information already created before passing it off the Vulkan
                                API:
                                    1
                                           let instance_info = vk::InstanceCreateInfo::builder()
                                    2
                                               .application_info(&app_info)
                                    3
                                               .enabled_layer_names(&wanted_layers_raw)
                                    4
                                               .enabled_extension_names(&wanted_extensions_raw);
                                    5
                                    6
                                           let instance = unsafe { entry.create_instance(&instance_info, None)? };
                                The unsafe block is needed since the Vulkan API is all written in C,
                                which is an unsafe language. Now if everything works correctly,
                                 instance now stores a handle to a VkInstance object and thevVulkan
                                API can be used.
                                I tested this code by adding LunarG’s api dump validation layer,
                                which will log the call to create_instance, running the application
                                yielded:
                                vkCreateInstance(pCreateInfo, pAllocator, pInstance) returns VkResult VK_SUCCESS (0):
                                    pCreateInfo:                    const VkInstanceCreateInfo* = 0x7fff89b19290:
                                        sType:                          VkStructureType =
                                VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO (1)
                                        pNext:                          const void* = NULL
                                        flags:                          VkInstanceCreateFlags = 0
                                        pApplicationInfo:               const VkApplicationInfo* = 0x7fff89b1cf00:o
                                            sType:                          VkStructureType =
                                VK_STRUCTURE_TYPE_APPLICATION_INFO (0)
                                            pNext:                          const void* = NULL
                                            pApplicationName:               const char* = "aetheria"
                                            applicationVersion:             uint32_t = 4194304
                                            pEngineName:                    const char* = "aetheria"
                                            engineVersion:                  uint32_t = 4194304
                                            apiVersion:                     uint32_t = 4206830
                                        enabledLayerCount:              uint32_t = 2
                                        ppEnabledLayerNames:            const char* const* = 0x5571fe7341c0
                                            ppEnabledLayerNames[0]:         const char* const =
                                "VK_LAYER_LUNARG_api_dump"
                                            ppEnabledLayerNames[1]:         const char* const =
                                "VK_LAYER_KHRONOS_validation"
                                        enabledExtensionCount:          uint32_t = 0
                                        ppEnabledExtensionNames:        const char* const* = 0x5571fe7341e0
                                        pNext:                          const void* = NULL
                                    pAllocator:                     const VkAllocationCallbacks* = NULL
                                    pInstance:                      VkInstance* = 0x5571fe7312e0
                                From this I can tell this code is working correctly, because the
                                instance create info contains both validation layer names as well as
                                the correct application info, the versions numbers are a bit odd
                                because of the encoding Vulkan uses for versions. With instance
                                creation complete I moved on to physical devices
                                4.1.2.Physical Devices
                                Physical devices are how Vulkan represents a piece of GPU hardware,
                                having a VkPhysicalDevice handle allows the application to request
                                properties and capabilities of the GPU in order to check if the GPU
                                is suitable for the application’s needs. I decided the encapsulate
                                the VkPhysicalDevice handle in a struct I called PhysicalDevice, which
                                fetched and stored all of the data for a device when it’s created to
                                avoid constantly fetching the same data.
                                    1
                                             #[derive(Debug, Clone)]
                                    2
                                             pub struct PhysicalDevice {
                                    3
                                                 pub(crate) physical: vk::PhysicalDevice,
                                    4
                                                 pub properties: PhysicalDeviceProperties,
                                    5
                                                 pub queue_families: Vec<vk::QueueFamilyProperties>,
                                    6
                                                 pub features: vk::PhysicalDeviceFeatures,
                                    7
                                             }
                                    8
                                    9
                                             impl PhysicalDevice {
                                    10
                                                 unsafe fn new(instance: &Instance, physical: vk::PhysicalDevice) -> Self {
                                    11
                                                     let properties = instance.get_physical_device_properties(physical);
                                    12
                                                     let properties = PhysicalDeviceProperties::new(&properties);
                                    13
                                                     let queue_families =
                                             instance.get_physical_device_queue_family_properties(physical);
                                    14
                                                     let features = instance.get_physical_device_features(physical);
                                    15
                                    16
                                                     Self {
                                    17
                                                         physical,
                                    18
                                                         properties,
                                    19
                                                         queue_families,
                                    20
                                                         features,
                                    21
                                                     }
                                    22
                                                 }
                                    23
                                             }
                                The struct stores a handle to the physical device, a
                                 PhysicalDeviceProperties instance (an encapsulation I built to turn
                                any string properties into nice Rust Strings) which contains static
                                properties such as the device’s name, or whether its a discrete or
                                integrated GPU, etc. The vk::PhysicalDeviceFeatures instance stores a
                                list of possible features and whether they are supported on the
                                device, such as anisotropic filtering. And finally it stores a
                                vector of QueueFamilyProperties instances, which I’ll come to when I
                                talk about queues later.
                                With physical devices encapsulated, I now needed a way of fetching
                                device handles and instantiating the struct, I created a method
                                called get_physical_devices on Instance
                                    1
                                             impl Instance {
                                    2
                                               ...
                                    3
                                    4
                                               pub fn get_physical_devices(&self) -> Result<Vec<PhysicalDevice>,
                                             vk::Result> {
                                    5
                                                 let physicals = unsafe { self.enumerate_physical_devices()? };
                                    6
                                                 unsafe {
                                    7
                                                   Ok(physicals
                                    8
                                                     .iter()
                                    9
                                                     .cloned()
                                    10
                                                     .map(|physical| PhysicalDevice::new(self, physical))
                                    11
                                                     .collect())
                                    12
                                                 }
                                    13
                                               }
                                    14
                                             }
                                I needed to test all this code, so I wrote some temporary entrypoint
                                code that loads Vulkan, creates an Instance and then gets a
                                 PhysicalDevice:
                                    1
                                             use ash::Entry;
                                    2
                                    3
                                             mod vulkan;
                                    4
                                    5
                                             fn main() {
                                    6
                                               let entry = Entry::linked();
                                    7
                                               let instance = vulkan::Instance::new(&entry).expect("Vulkan instance
                                             creation failed");
                                    8
                                               let physicals = instance.get_physical_devices().expect("Fetching physical
                                             devices failed");
                                    9
                                               let physical = physicals.first().expect("No vulkan compatible devices");
                                    10
                                               println!("{}", physical.properties.device_name);
                                    11
                                             }
                                The output of the program will depend on the GPUs in the computer
                                running it, but on my desktop it prints NVIDIA GeForce GTX 1050 Ti,
                                which is my discrete GPU for my desktop. Because PhysicalDevice
                                derives the Debug trait, I am also able to print out the
                                 PhysicalDevice object itself, which I did during testing, however the
                                output is very long so I won’t show it here.
                                4.1.3.Surfaces
                                Surfaces are the first step in Vulkan’s presentation system, they
                                are a platform-independant handle to a window, which can then be
                                used to present image to, as well as getting information about the
                                window such as width and height. Like the rest of the presentation
                                system, surfaces are behind an extension, in this case the
                                 VK_KHR_surface extension, in addition there are also operating system
                                specific extensions for surface creation, for Linux I chose
                                 VK_KHR_xlib_surface, I’m ignoring MacOS at the moment as I don’t have
                                a mac to test on, and I’ll add windows support at a later point. I
                                started by adding these extensions to the get_wanted_extension
                                function:
                                    1
                                           #[cfg(target_os = "linux")]
                                    2
                                           fn get_wanted_extensions() -> Vec<&'static CStr> {
                                    3
                                               vec![khr::Surface::name(), khr::XlibSurface::name()]
                                    4
                                           }
                                The ash create provides some convenient functions for getting an
                                extension’s name to avoid typos, which is what I use here. Line 1
                                makes it so that this function is only declared when compiling for
                                Linux, so I can have platform specific code that is swapped out at
                                compile time. With that done the extensions are being added when the
                                instance is created, but they still have to be loaded, as the
                                address of the functions for an extension are unknown. The ash
                                create handles loading extensions by creating a struct that
                                encapsulates all of an extension’s functions, its these structs that
                                have the name methods I used above. Because these instances have to
                                be stores somewhere I created an InstanceExtensions struct:
                                    1
                                             #[derive(Clone)]
                                    2
                                             pub struct InstanceExtensions {
                                    3
                                                 pub surface: Option<khr::Surface>,
                                    4
                                                 pub xlib_surface: Option<khr::XlibSurface>,
                                    5
                                             }
                                    6
                                    7
                                             impl InstanceExtensions {
                                    8
                                               pub fn load(entry: &ash::Entry, instance: &ash::Instance, available:
                                             &[&CStr]) -> Self {
                                    9
                                                 Self {
                                    10
                                                   surface: available
                                    11
                                                     .iter()
                                    12
                                                     .find(|ext| **ext == khr::Surface::name())
                                    13
                                                     .map(|_| khr::Surface::new(entry, instance)),
                                    14
                                                   xlib_surface: available
                                    15
                                                     .iter()
                                    16
                                                     .find(|ext| **ext == khr::XlibSurface::name())
                                    17
                                                     .map(|_| khr::XlibSurface::new(entry, instance)),
                                    18
                                                 }
                                    19
                                               }
                                    20
                                             }
                                The struct stores the extensions in an Option<T> enum so I can have
                                optional extensions in the future, the InstanceExtension::load method
                                also checks if the extensions are available before loading them, so
                                the program won’t crash. I added loading extensions to instance
                                creation:
                                    1
                                             pub struct Instance {
                                    2
                                               instance: ash::Instance,
                                    3
                                               pub extensions: InstanceExtensions
                                    4
                                             }
                                    5
                                    6
                                             impl Instance {
                                    7
                                               pub fn new(entry: &ash::Entry) {
                                    8
                                                 ...
                                    9
                                    10
                                                 Ok(Self {
                                    11
                                                   extensions: InstanceExtensions::load(entry, &instance,
                                             &available_extension_names),
                                    12
                                                   instance
                                    13
                                                 })
                                    14
                                               }
                                    15
                                             }
                                The last thing I needed before creating a surface was to actually
                                create the window I was going to use to present the game to the
                                user, I decided to use a crate called winit for this. winit has two
                                main objects, the Window and the EventLoop which are created as
                                shown below:
                                    1
                                           pub fn main() {
                                    2
                                             let event_loop = winit::event_loop::EventLoop::new();
                                    3
                                             let window = winit::window::WindowBuilder::new()
                                    4
                                               .build(&event_loop)
                                    5
                                               .unwrap();
                                    6
                                    7
                                             ...
                                    8
                                           }
                                Once everything else is initialised, the application begins its main
                                loop using winit’s EventLoop::run method:
                                    1
                                             pub fn main() {
                                    2
                                               ...
                                    3
                                    4
                                               event_loop.run(move |event, _, control_flow| {
                                    5
                                                 control_flow.set_poll();
                                    6
                                                 match event {
                                    7
                                                   winit::event::Event::WindowEvent {
                                    8
                                                     event: winit::event::WindowEvent::CloseRequested,
                                    9
                                                     ..
                                    10
                                                   } => {
                                    11
                                                     control_flow.set_exit();
                                    12
                                                   }
                                    13
                                                   winit::event::Event::DeviceEvent { event:
                                             winit::event::DeviceEvent::Key(input), .. } => {
                                    14
                                                     if let Some(key) = input.virtual_keycode && key ==
                                             winit::event::VirtualKeyCode::Escape {
                                    15
                                                       control_flow.set_exit();
                                    16
                                                     }
                                    17
                                                   }
                                    18
                                                   _ => {}
                                    19
                                                 }
                                    20
                                               })
                                    21
                                             }
                                This event handler closes the window if the user presses the
                                operating system’s close button, or if the Escape key is pressed. It
                                also sets the control flow to Poll, meaning the event loop with be
                                run each frame, which is needed for a video game. With the window
                                initialised I now moved on to surface creation.
                                To create the surface for Linux, I needed to fill out a
                                 XlibSurfaceCreateInfo struct which took some raw handles to the x11
                                window, then I passed it into the xlib surface extension and got the
                                surface handle from that:
                                    1
                                             pub struct Surface {
                                    2
                                               pub(crate) surface: vk::SurfaceKHR,
                                    3
                                             }
                                    4
                                    5
                                             impl Surface {
                                    6
                                               #[cfg(target_os = "linux")]
                                    7
                                               pub fn new(instance: &Instance, window: &Window) -> Result<Self, vk::Result>
                                             {
                                    8
                                                 let create_info = vk::XlibSurfaceCreateInfoKHR::builder()
                                    9
                                                   .dpy(window.xlib_display().unwrap() as *mut *const c_void)
                                    10
                                                   .window(window.xlib_window().unwrap());
                                    11
                                    12
                                                 let surface = unsafe {
                                    13
                                                   instance
                                    14
                                                     .extensions
                                    15
                                                     .xlib_surface
                                    16
                                                     .as_ref()
                                    17
                                                     .unwrap()
                                    18
                                                     .create_xlib_surface(&create_info, None)?
                                    19
                                                 };
                                    20
                                    21
                                                 Ok(Self { surface })
                                    22
                                               }
                                    23
                                             }
                                With the surface constructed, the next step was to create the
                                logical device and some queues.
                                4.1.4.Execution Model
                                Before I get to logical devices, I needed to do some research into
                                Vulkan’s execution model so I understood what queues were. All
                                operations in Vulkan have to be recorded into CommandBuffer objects,
                                from drawing to rescaling an image. Once these CommandBuffer objects
                                are recorded they can be submitted to a Queue on the GPU, queues are
                                a bit like threads but on a GPU, each queue can have a CommandBuffer
                                submitted, so multiple CommandBuffer object can be executed at once.
                                For this program I am only using one queue so the graphics code will
                                be executed like a single-threaded program, I decided this because
                                of the extra complexity multi-threaded GPU code would create. Each
                                queue belongs to a queue family, which is a collection of queues
                                with the same capabilities, such as presenting, or running compute
                                shaders. Using the CPU analogy, queues would be the threads and
                                queue families would be the cores.
                                Now I knew what Queues were, I was ready to create a logical device.
                                4.1.5.Devices and Queues
                                Devices are the most important structure in Vulkan, they represent a
                                handle to a device the program can use to execute command buffers,
                                draw pretty picture and present to the screen. Looking at the ash
                                documentation for DeviceCreateInfo:
                                    1
                                             pub struct DeviceCreateInfo {
                                    2
                                                 pub s_type: StructureType,
                                    3
                                                 pub p_next: *const c_void,
                                    4
                                                 pub flags: DeviceCreateFlags,
                                    5
                                                 pub queue_create_info_count: u32,
                                    6
                                                 pub p_queue_create_infos: *const DeviceQueueCreateInfo,
                                    7
                                                 pub enabled_layer_count: u32,
                                    8
                                                 pub pp_enabled_layer_names: *const *const c_char,
                                    9
                                                 pub enabled_extension_count: u32,
                                    10
                                                 pub pp_enabled_extension_names: *const *const c_char,
                                    11
                                                 pub p_enabled_features: *const PhysicalDeviceFeatures,
                                    12
                                             }
                                Ignoring s_type, p_next and flags, I needed 4 things for the
                                 DeviceCreateInfo: an array of DeviceQueueCreateInfo, an array of
                                enabled validation layers, an array of enabled device extensions,
                                and finally a refernce to a PhysicalDeviceFeatures object.
                                I’m skipping over extensions and validation layers because the code
                                is very similar to Instance creation above.
                                4.2. 2023-07-25 - Buffer Race Conditions
                                4.2.1.The Problem
                                Occasionally, especially on my desktop, I’d notice missing chunks of
                                vertex data. Upon investigation with RenderDoc I saw that the first
                                64 bytes of the vertex buffer was being set to a strange constant
                                value.
                                4.2.2.Debugging
                                Using RenderDoc I traced back into the memory arena that buffer
                                allocations were coming from, the same memory offset was being
                                assigned to two buffers in the same frame.
                                Now this in theory wouldn’t be an issue since the first buffer was
                                being used in the render pass, and the second in the UI pass,
                                however the GPU wasn’t waiting properly when I was allocating and
                                writing memory, even when I told the device to wait till idle on
                                every write (which incurred a heavy performance penalty). The issue
                                was due to the fact I was deallocating memory according to Rust
                                lifetimes, i.e. when a resource goes out of scope rather than GPU
                                lifetimes which were a lot longer, hence the race condition.
                                4.2.3.The Fix
                                The solution was to record frees into a “to free” buffer and flush
                                that buffer when the program could guarantee the GPU wouldn’t be
                                using any resources and with this the vertex buffer corruption
                                seemed to disappear. It’s not the best solution and it locks me out
                                of frames-in-flight so I may need to revisit it, however that won’t
                                be too hard since part of my debugging resulted in me writing a
                                custom allocator and dropping and gpu_allocator requirement, so it
                                will be easier to extend in future.
                                Here’s an example of batching frees:
                                TODO: Add code snippets and more detail
                                4.3. 2023-08-02 - Client Server Representation
                                With gathering and a basic inventory implemented on the client-side,
                                I ran a brief playtest sending an executable and IP address to a few
                                friends who are interested in the project. The resounding feedback
                                was that were was no persistence, if they logged off and logged back
                                in, their items would have been lost, this is because at the moment
                                the server has no concept of an inventory or gathering, I was
                                planning to move on to crafting and revisit this later but with the
                                feedback recieved I decided to prioritise this issue.
                                The first issue was going to be where to store the game data, below
                                is a table evaluating the
                                     Option                                                          Advantages                                                           Disadvantages
                                                                                                     • Minimises server                                                   • Easy to tamper
                                                                                                           load                                                                with data
                                     Client-side storage
                                                                                                     • No need to sync                                                    • Client is not
                                                                                                           data with server                                                    always online
                                                                                                     • Very difficult to
                                                                                                                                                                          • Increased server
                                                                                                           tamper with data
                                                                                                                                                                               load
                                                                                                     • Data is all in one
                                     Server-side storage                                                                                                                  • Clients need to
                                                                                                           place
                                                                                                                                                                               tell server about
                                                                                                     • Data is always
                                                                                                                                                                               all data changes
                                                                                                           accessible
                                Since this system would be used to store inventory data it must be
                                tamper-proof, otherwise it would be too easy for players to cheat
                                items into the game, and any sort of economy would be impossible.
                                Because of this I decided the server would have to store the data in
                                some sort of central database. The server load issue this creates
                                can be minimised using client prediction which I’ll get to later in
                                this devlog.
                                The choice to store data on the server then presents another issue,
                                the same objects will often be represented differently on the client
                                and server, for example here the client and server Player struct:
                                    1
                                           struct Player {
                                    2
                                               player: RenderObject,
                                    3
                                               jump_t: f32,
                                    4
                                               light: Light
                                    5
                                           }
                                    1
                                           struct Player {
                                    2
                                               position: Vec3,
                                    3
                                               username: String,
                                    4
                                               inventory: Inventory,
                                    5
                                           }
                                The data is completely different, the server Player contains a
                                username and inventory, whereas on the client these are separate
                                systems. This is an example of a struct that should be kept separate
                                between server and client, however there are structs with more in
                                common between server and client such as the Item enum which
                                contains a list of all items in the game, at this point I moved
                                these more common data structures into a common crate which can be
                                used by both the client and server crates.
                                So far the network protocol had been manually encoding data into
                                bytes which lead to a lot of bugs and errors along the way. Luckily
                                someone has made an amazing crate called serde which allows
                                automatic encoding and decoding of data structures. In addition to
                                 serde, I needed a crate that encodes data into a tightly packet
                                binary stream, I took a while to look through the option and it
                                seemed like postcard was the best option. Refactoring to use serde
                                and postcard took the network code from
                                    1
                                             #[derive(FromPrimitive, ToPrimitive)]
                                    2
                                             pub enum ServerboundOpcode {
                                    3
                                                 Login,
                                    4
                                                 Move,
                                    5
                                                 Heartbeat,
                                    6
                                                 Disconnect,
                                    7
                                             }
                                    8
                                    9
                                             pub struct ServerboundPacket {
                                    10
                                                 pub opcode: ServerboundOpcode,
                                    11
                                                 pub payload: Vec<u8>,
                                    12
                                             }
                                    13
                                    14
                                             #[derive(FromPrimitive, ToPrimitive)]
                                    15
                                             pub enum ClientboundOpcode {
                                    16
                                                 SpawnPlayer,
                                    17
                                                 Move,
                                    18
                                                 DespawnPlayer,
                                    19
                                                 NotifyDisconnection,
                                    20
                                                 Kick,
                                    21
                                             }
                                    22
                                    23
                                             pub struct ClientboundPacket {
                                    24
                                                 pub opcode: ClientboundOpcode,
                                    25
                                                 pub payload: Vec<u8>,
                                    26
                                             }
                                    27
                                    28
                                             impl ClientboundPacket {
                                    29
                                                 pub fn to_bytes(&self) -> Vec<u8> {
                                    30
                                                     let mut data = Vec::new();
                                    31
                                                     data.extend(&self.opcode.to_u32().unwrap().to_be_bytes());
                                    32
                                                     data.extend(&self.payload.clone());
                                    33
                                                     let mut packet = data.len().to_be_bytes().to_vec();
                                    34
                                                     packet.append(&mut data);
                                    35
                                                     packet
                                    36
                                                 }
                                    37
                                             }
                                    38
                                    39
                                             impl ServerboundPacket {
                                    40
                                                 pub fn to_bytes(&self) -> Vec<u8> {
                                    41
                                                     let mut data = Vec::new();
                                    42
                                                     data.extend(&self.opcode.to_u32().unwrap().to_be_bytes());
                                    43
                                                     data.extend(&self.payload.clone());
                                    44
                                                     let mut packet = data.len().to_be_bytes().to_vec();
                                    45
                                                     packet.append(&mut data);
                                    46
                                                     packet
                                    47
                                                 }
                                    48
                                             }
                                to
                                    1
                                             pub mod server {
                                    2
                                                 use serde::{Deserialize, Serialize};
                                    3
                                    4
                                                 #[derive(Serialize, Deserialize, Debug, Clone)]
                                    5
                                                 pub struct Login {
                                    6
                                                     pub username: String,
                                    7
                                                 }
                                    8
                                    9
                                                 #[derive(Serialize, Deserialize, Debug, Clone)]
                                    10
                                                 pub struct Move {
                                    11
                                                     pub position: glam::Vec3,
                                    12
                                                 }
                                    13
                                    14
                                                 #[derive(Serialize, Deserialize, Debug, Clone)]
                                    15
                                                 pub enum Packet {
                                    16
                                                     Login(Login),
                                    17
                                                     Move(Move),
                                    18
                                                     Heartbeat,
                                    19
                                                     Disconnect,
                                    20
                                                 }
                                    21
                                             }
                                    22
                                    23
                                             pub mod client {
                                    24
                                                 use serde::{Deserialize, Serialize};
                                    25
                                    26
                                                 #[derive(Serialize, Deserialize, Debug, Clone)]
                                    27
                                                 pub struct SpawnPlayer {
                                    28
                                                     pub username: String,
                                    29
                                                     pub position: glam::Vec3,
                                    30
                                                 }
                                    31
                                    32
                                                 #[derive(Serialize, Deserialize, Debug, Clone)]
                                    33
                                                 pub struct DespawnPlayer {
                                    34
                                                     pub username: String,
                                    35
                                                 }
                                    36
                                    37
                                                 #[derive(Serialize, Deserialize, Debug, Clone)]
                                    38
                                                 pub struct Move {
                                    39
                                                     pub username: String,
                                    40
                                                     pub position: glam::Vec3,
                                    41
                                                 }
                                    42
                                    43
                                                 #[derive(Serialize, Deserialize, Debug, Clone)]
                                    44
                                                 pub struct NotifyDisconnection {
                                    45
                                                     pub reason: String,
                                    46
                                                 }
                                    47
                                    48
                                                 #[derive(Serialize, Deserialize, Debug, Clone)]
                                    49
                                                 pub enum Packet {
                                    50
                                                     SpawnPlayer(SpawnPlayer),
                                    51
                                                     DespawnPlayer(DespawnPlayer),
                                    52
                                                     Move(Move),
                                    53
                                                     NotifyDisconnection(NotifyDisconnection),
                                    54
                                                 }
                                    55
                                             }
                                Here’s an example of where it simplified the most code, this is
                                server side decoding before and after this change:
                                    1
                                             let packet_size =
                                    2
                                                 if let Some(array) = buf.get(0..8).and_then(|bytes| bytes.try_into().ok())
                                             {
                                    3
                                                     u64::from_be_bytes(array)
                                    4
                                                 } else {
                                    5
                                                     warn!("Failed to read packet due to underflow");
                                    6
                                                     continue;
                                    7
                                                 };
                                    8
                                    9
                                             let Some(packet) = buf.get(8..(packet_size as usize + 8)) else {
                                    10
                                                 warn!("Failed to read packet due to underflow");
                                    11
                                                 continue
                                    12
                                             };
                                    13
                                    14
                                             let opcode =
                                    15
                                                 if let Some(array) = packet.get(0..4).and_then(|bytes|
                                             bytes.try_into().ok()) {
                                    16
                                                     u32::from_be_bytes(array)
                                    17
                                                 } else {
                                    18
                                                     warn!("Packet of size {} is too short", packet.len());
                                    19
                                                     continue;
                                    20
                                                 };
                                    21
                                    22
                                             let Some(opcode) = ServerboundOpcode::from_u32(opcode) else {
                                    23
                                                 warn!("Invalid opcode: {}", opcode);
                                    24
                                                 continue
                                    25
                                             };
                                    26
                                    27
                                             let Some(payload) = packet.get(4..).map(<[u8]>::to_vec) else {
                                    28
                                                warn!("Failed to read packet body");
                                    29
                                                continue
                                    30
                                             };
                                    31
                                    32
                                             let packet = ServerboundPacket { opcode, payload };
                                to just:
                                    1
                                             let packet = match postcard::from_bytes(&buf) {
                                    2
                                                 Ok(packet) => packet,
                                    3
                                                 Err(e) => {
                                    4
                                                     warn!("Failed to decode packet due to {}", e);
                                    5
                                                     continue;
                                    6
                                                 }
                                    7
                                             };
                                    8
                                    9
                                             if let Err(e) = handle_packet(&mut server, &packet, addr) {
                                    10
                                                 warn!("Handling packet failed with {e}");
                                    11
                                                 continue;
                                    12
                                             }
                                It also made using the packet payloads a lot easier since the
                                handlers don’t have to worry about decoding the binary, for example:
                                    1
                                             let username = match String::from_utf8(packet.payload.clone()) {
                                    2
                                                 Ok(str) => str.trim().to_owned(),
                                    3
                                                 Err(e) => {
                                    4
                                                     warn!("Failed to parse username: {}", e);
                                    5
                                                     if let Err(e) = disconnect(server, addr, Some("Invalid
                                             username".to_owned())) {
                                    6
                                                         warn!("Failed to disconnect client due to {}", e);
                                    7
                                                     }
                                    8
                                                     return;
                                    9
                                                 }
                                    10
                                             };
                                    11
                                             let client = Client {
                                    12
                                                 username,
                                    13
                                                 player_translation: Vec3::new(0.0, 0.0, 0.0),
                                    14
                                                 last_heartbeat: Instant::now(),
                                    15
                                             };
                                became just:
                                    1
                                           let client = Client {
                                    2
                                               username: packet.username.clone(),
                                    3
                                               player_translation: Vec3::new(0.0, 0.0, 0.0),
                                    4
                                               last_heartbeat: Instant::now(),
                                    5
                                           };
                                While testing all server functionality I found the player would
                                jitter when moving and peers positions would not update, looking at
                                client logs when client A would move, client A would recieve a
                                packet updating its position, client B wouldn’t. Must be a server
                                bug, issue was when sending the movement update packets, taking a
                                look at the server-side handle_move function:
                                    1
                                             fn handle_move(server: &mut Server, packet: &net::server::Move, addr:
                                             SocketAddr) {
                                    2
                                                 // Find client, early returning if not found
                                    3
                                                 let Some(client) = server
                                    4
                                                     .connections
                                    5
                                                     .get_mut(&addr) else {
                                    6
                                                         warn!("Cannot find client for addr {}", addr);
                                    7
                                                         return;
                                    8
                                                     };
                                    9
                                    10
                                                 client.player_translation = packet.position;
                                    11
                                    12
                                                 info!(
                                    13
                                                     "Updated position for {} to {:?}",
                                    14
                                                     client.username, client.player_translation
                                    15
                                                 );
                                    16
                                    17
                                                 // Have to refetch to drop the mutable reference
                                    18
                                                 let Some(client) = server
                                    19
                                                     .connections
                                    20
                                                     .get(&addr) else {
                                    21
                                                         warn!("Cannot find client for addr {}", addr);
                                    22
                                                         return;
                                    23
                                                     };
                                    24
                                    25
                                                 for peer_addr in server.connections.keys() {
                                    26
                                                     if *peer_addr == addr { // Don't want to send to itself, will cause
                                             jitter
                                    27
                                                         continue;
                                    28
                                                     }
                                    29
                                    30
                                                     // Prepare packet
                                    31
                                                     let packet = net::client::Packet::Move(net::client::Move {
                                    32
                                                         username: client.username.clone(),
                                    33
                                                         position: client.player_translation
                                    34
                                                     });
                                    35
                                    36
                                                     if let Err(e) = server.send(addr, &packet) {
                                    37
                                                         warn!(
                                    38
                                                             "Failed to notify {} of {} moving due to {}",
                                    39
                                                             peer_addr, client.username, e
                                    40
                                                         );
                                    41
                                                         continue;
                                    42
                                                     }
                                    43
                                                 }
                                    44
                                             }
                                The issue was with the destination address of the packet, I was
                                sending them to addr which was the address of the client that sent
                                the packet. I should have been sending them to the peer’s address,
                                stored in peer_addr, here are the changes I made to fix it:
                                    1
                                           if let Err(e) = server.send(addr, &packet) {
                                    2
                                               warn!(
                                    3
                                                   "Failed to notify {} of {} moving due to {}",
                                    4
                                                   peer_addr, client.username, e
                                    5
                                               );
                                    6
                                               continue;
                                    7
                                           }
                                needed to be:
                                    1
                                           if let Err(e) = server.send(*peer_addr, &packet) {
                                    2
                                               warn!(
                                    3
                                                   "Failed to notify {} of {} moving due to {}",
                                    4
                                                   peer_addr, client.username, e
                                    5
                                               );
                                    6
                                               continue;
                                    7
                                           }
                                The dereference was needed as the peer_addr was borrowed from the
                                hashmap of clients.
                                After testing again I found another issue, the first client would
                                connect fine, second client would connect and the first would crash
                                due to ‘Unknown peer’, this meant there was an issue with the
                                 handle_login function and it wasn’t notifying peers about a new
                                connection.
                                    1
                                             fn handle_login(server: &mut Server, packet: &net::server::Login, addr:
                                             SocketAddr) {
                                    2
                                                 let client = Client {
                                    3
                                                     username: packet.username.clone(),
                                    4
                                                     player_translation: Vec3::new(0.0, 0.0, 0.0),
                                    5
                                                     last_heartbeat: Instant::now(),
                                    6
                                                 };
                                    7
                                    8
                                                 // Notify peers about new client
                                    9
                                                 for peer_addr in server.connections.keys() {
                                    10
                                                     let packet = net::client::Packet::SpawnPlayer(net::client::SpawnPlayer
                                             {
                                    11
                                                         username: client.username.clone(),
                                    12
                                                         position: client.player_translation,
                                    13
                                                     });
                                    14
                                                     if let Err(e) = server.send(addr, &packet) {
                                    15
                                                         warn!("Failed to notify {} of new player due to {}", peer_addr,
                                             e);
                                    16
                                                     }
                                    17
                                                 }
                                    18
                                    19
                                                 // Notify client about existing peers
                                    20
                                                 for (peer_addr, peer_client) in &server.connections {
                                    21
                                                     let packet = net::client::Packet::SpawnPlayer(net::client::SpawnPlayer
                                             {
                                    22
                                                         username: peer_client.username.clone(),
                                    23
                                                         position: peer_client.player_translation,
                                    24
                                                     });
                                    25
                                                     if let Err(e) = server.send(addr, &packet) {
                                    26
                                                         warn!(
                                    27
                                                             "Failed to notify new player {} of player {} due to {}",
                                    28
                                                             addr, peer_addr, e
                                    29
                                                         );
                                    30
                                                     }
                                    31
                                                 }
                                    32
                                    33
                                                 info!("Added {} to connection list", client.username);
                                    34
                                                 server.connections.insert(addr, client);
                                    35
                                             }
                                Taking a look it was the same bug as before, now on line 14, the
                                first client was complaining about unknown peers because it wasn’t
                                being notified, the newly connected client was as addr was being
                                used instead of peer_addr. This can be fixed with a quick change:
                                    1
                                             // Notify peers about new client
                                    2
                                             for peer_addr in server.connections.keys() {
                                    3
                                                 let packet = net::client::Packet::SpawnPlayer(net::client::SpawnPlayer {
                                    4
                                                     username: client.username.clone(),
                                    5
                                                     position: client.player_translation,
                                    6
                                                 });
                                    7
                                                 if let Err(e) = server.send(addr, &packet) {
                                    8
                                                     warn!("Failed to notify {} of new player due to {}", peer_addr, e);
                                    9
                                                 }
                                    10
                                             }
                                should have been:
                                    1
                                             // Notify peers about new client
                                    2
                                             for peer_addr in server.connections.keys() {
                                    3
                                                 let packet = net::client::Packet::SpawnPlayer(net::client::SpawnPlayer {
                                    4
                                                     username: client.username.clone(),
                                    5
                                                     position: client.player_translation,
                                    6
                                                 });
                                    7
                                                 if let Err(e) = server.send(*peer_addr, &packet) {
                                    8
                                                     warn!("Failed to notify {} of new player due to {}", peer_addr, e);
                                    9
                                                 }
                                    10
                                             }
                                And with that everything was working again, now the server and
                                client both had access to the item data and networking was
                                refactored I finally moved onto inventory syncing. I chose the
                                simplest approach, the client notifes the server about a new item,
                                this approach has a few issues, mainly that it would be very easy to
                                spawn items in since there can be no validation. Eventually I’d want
                                to make the client tell the server about an action such as gathering
                                or crafting, and then the server validates the action and calculates
                                the resulting effects such as modifying the player’s inventory, and
                                then notifies the client of the effects, however since the server
                                currently has no knowledge of the game world, and I said before
                                there’s little point until I start working on a static/procedurally
                                generated world, it can’t validate these actions so this simple
                                approach is all that’s possible.
                                Firstly I designed the packet ModifyInventory, it needed to both add
                                and remove item stacks (I chose item stacks over indiviual items to
                                reduce the number of packets being sent to the server), the struct
                                for the packet looked like this, I could simplify adding and
                                removing stacks by just making the server respond by setting the
                                stack quantity to the amount in the packet. So if the client sent a
                                packet with a stack containing (Wood, 4), the server would set that
                                player’s quantity of wood to 4. If its set to 0, its treated as
                                deleting the stack.
                                    1
                                           #[derive(Serialize, Deserialize, Debug, Clone)]
                                    2
                                           pub struct ModifyInventory {
                                    3
                                               stack: ItemStack
                                    4
                                           }
                                Now I had to hook into Inventory struct’s add method, and whenever
                                it is called dispatch a ModifyInventory packet to the server. With
                                the current system with Inventory in the common crate, this was very
                                difficult as whatever changes were made would affect both the server
                                and client, I needed a way of specifying behaviour specific to the
                                client or the server, so far I had only done this with data. Here
                                are a couple solutions I came up with and evalutated:
                                     Option                                                             Advantages                                                         Disadvantages
                                                                                                                                                                           • Adds a layer of
                                                                                                             Function
                                                                                                        •                                                                        indirection when
                                                                                                             signatures remain                                                   you call a
                                                                                                             the same as the                                                     function, unknown
                                     Inject middleware                                                       closures will                                                       side-effects,
                                     closures that are                                                       capture any side                                                    could lead to
                                     called when the                                                         specific state                                                      accidental
                                     method is called                                                   • Adding middleware                                                      deadlocks or
                                                                                                             capabilities could                                                  performance issues
                                                                                                             be automated with                                             • Makes constructors
                                                                                                             a macro                                                             a lot more
                                                                                                                                                                                 complicated
                                                                                                                                                                           • Data and code
                                                                                                                                                                                 could be
                                     Move the struct
                                                                                                                                                                                 duplicated,
                                     from the common                                                    • Easy to do
                                                                                                                                                                                 possibly causing a
                                     crate into seperate                                                • No complex
                                                                                                                                                                                 data desync
                                     server and client                                                       constructors
                                                                                                                                                                           • Common crate has
                                     structs
                                                                                                                                                                                 no knowledge of
                                                                                                                                                                                 this system
                                                                                                                                                                           • Data and code
                                                                                                                                                                                 could be
                                                                                                        • Useful if the
                                     Swap the struct for                                                                                                                         duplicated,
                                                                                                             common crate needs
                                     a trait which then                                                                                                                          possibly causing a
                                                                                                             to use the system
                                     the side specific                                                                                                                           data desync,
                                                                                                             as it can be
                                     structs implement                                                                                                                           however this can
                                                                                                             passed as a
                                     aka dependency                                                                                                                              be reduced using
                                                                                                              &dyn Trait
                                     injection                                                                                                                                   default
                                                                                                        • Easy to do
                                                                                                                                                                                 implementations
                                                                                                                                                                           • Boilerplate
                                                                                                        • Easy to do
                                                                                                                                                                                 Code has to be
                                                                                                                                                                           •
                                                                                                        • Useful if the
                                                                                                                                                                                 written in the
                                     Use features to
                                                                                                             common crate needs
                                                                                                                                                                                 common crate, so
                                     disable certain
                                                                                                             to use the system
                                                                                                                                                                                 it can’t use any
                                     functions
                                                                                                             as it can be
                                                                                                                                                                                 client/server
                                                                                                             passed as a
                                                                                                                                                                                 specific bits
                                                                                                              &dyn Trait
                                                                                                                                                                           • Common crate can’t
                                     Wrap the struct                                                                                                                             use the
                                                                                                        • Allows for the use
                                     with a new struct                                                                                                                           specialised
                                                                                                             of code in side
                                     in the side                                                                                                                                 methods
                                                                                                             specific crates
                                     specific crates                                                                                                                       • Results in a bit
                                                                                                                                                                                 of boilerplate
                                                                                                        • Observers can be
                                                                                                             registered from
                                                                                                                                                                           • Can add a little
                                     Observables                                                             either side to
                                                                                                                                                                                 boilerplate
                                                                                                             watch the changes
                                                                                                             and respond
                                I don’t think there’s a one size fits all solution to this senario,
                                but in the case of the Inventory struct I decided to keep the
                                 Inventory struct split and have different structs and code on the
                                client and server sides, I was leaning towards observables but
                                working out whats changed can be very complicated and easy to
                                introduce bugs. The client side inventory needed to store a
                                reference to the socket so it could send packets, so the struct
                                looked like:
                                    1
                                           use common::ItemStack;
                                    2
                                    3
                                           struct Inventory {
                                    4
                                               inventory: Vec<ItemStack>,
                                    5
                                               socket: Arc<Socket>
                                    6
                                           }
                                and on the server to socket wasn’t needed so the struct looked like:
                                    1
                                           use common::ItemStack;
                                    2
                                    3
                                           struct Inventory {
                                    4
                                               inventory: Vec<ItemStack>
                                    5
                                           }
                                I may choose to replace the Vec<ItemStack> with some sort of indexed
                                map in future to bring lookups from O(n) to O(1), but for now the
                                vector is fine. With that done, I moved onto implementation, the
                                server implementation was just the same as the existing client
                                implementation so I copied that over before modifying the client
                                implementation to include sockets.
                                The only changes needed for the client was taking the socket
                                reference in the constructor and sending the packet when either add
                                or set were called. I chose to add a new private method called
                                 update that sent the ModifyInventory packet to the server.
                                    1
                                             impl Inventory {
                                    2
                                                 pub fn new(socket: Arc<Socket>) -> Self {
                                    3
                                                     Self {
                                    4
                                                         inventory: Vec::new(),
                                    5
                                                         socket
                                    6
                                                     }
                                    7
                                                 }
                                    8
                                    9
                                                 fn update(&self, item: Item) {
                                    10
                                                     let Some(stack) = self.inventory.iter().find(|s| s.item == item) else
                                             {
                                    11
                                                         warn!("Tried to update stack {:?} that doesn't exist", item);
                                    12
                                                         return;
                                    13
                                                     };
                                    14
                                    15
                                    16
                                                     let packet =
                                             net::server::Packet::ModifyInventory(net::server::ModifyInventory {
                                    17
                                                         stack: stack.clone()
                                    18
                                                     });
                                    19
                                                     if let Err(e) = self.socket.send(&packet) {
                                    20
                                                         warn!("Failed to update stack {:?} due to {}", item, e);
                                    21
                                                         return;
                                    22
                                                     }
                                    23
                                                 }
                                    24
                                    25
                                                 pub fn add(&mut self, stack: ItemStack) {
                                    26
                                                     if let Some(existing) = self.inventory.iter_mut().find(|s| s.item ==
                                             stack.item) {
                                    27
                                                         existing.amount += stack.amount;
                                    28
                                                     } else {
                                    29
                                                         self.inventory.push(stack);
                                    30
                                                     }
                                    31
                                    32
                                                     self.update(stack.item);
                                    33
                                                 }
                                    34
                                    35
                                                 pub fn set(&mut self, stack: ItemStack) {
                                    36
                                                     if let Some(existing) = self.inventory.iter_mut().find(|s| s.item ==
                                             stack.item) {
                                    37
                                                         existing.amount = stack.amount;
                                    38
                                                     } else {
                                    39
                                                         self.inventory.push(stack);
                                    40
                                                     }
                                    41
                                    42
                                                     self.update(stack.item);
                                    43
                                                 }
                                    44
                                    45
                                                 pub fn get_items(&self) -> &[ItemStack] {
                                    46
                                                     &self.inventory
                                    47
                                                 }
                                    48
                                             }
                                I handled the socket errors in the update function which is bad
                                practice but I didn’t want to be bubbling up Results everywhere,
                                eventually there may be a wrapper around the socket that attempts to
                                retry sending packets to recover from temporary losses of connection
                                but that’s a problem to solve in the future
                                With ModifyInventory packets being sent to the server, I now to
                                handle them by updating the server-side inventory for the player.
                                Firstly I updated the Connection struct to include an inventory:
                                    1
                                           struct Connection {
                                    2
                                               player_translation: Vec3,
                                    3
                                               username: String,
                                    4
                                               last_heartbeat: Instant,
                                    5
                                               inventory: Inventory // New
                                    6
                                           }
                                Next I needed the logic to update the item stacks on a
                                 ModifyInventory packet, I put this code in a new function called
                                 handle_modify_inventory:
                                    1
                                             fn handle_modify_inventory(server: &mut Server, packet:
                                             &net::server::ModifyInventory, addr: SocketAddr) {
                                    2
                                                 // Get connection
                                    3
                                                 let Some(connection) = server
                                    4
                                                     .connections
                                    5
                                                     .get_mut(&addr) else {
                                    6
                                                         warn!("Cannot find connection for addr {}", addr);
                                    7
                                                         return;
                                    8
                                                     };
                                    9
                                    10
                                                 // Update inventory
                                    11
                                                 connection.inventory.set(packet.stack);
                                    12
                                             }
                                Now the server was keeping track of the players’ inventories,
                                however when the connection was lost, the Connection structs were
                                dropped out of the HashMap, loosing the inventories in the process.
                                I needed to store player data separately from connection info so the
                                data can be reused by multiple connections. I came up with a couple
                                ways of doing this:
                                     Option                                                             Advantages                                                         Disadvantages
                                     Store a list of
                                     players and a list
                                     of connections,
                                                                                                                                                                           • Lots of Options to
                                     with each
                                                                                                                                                                                 handle due to
                                     connection storing                                                 • Simple to store
                                                                                                                                                                                 searching for
                                     the player’s
                                                                                                                                                                                 players
                                     username so the
                                     player can be
                                     searched for
                                                                                                                                                                           • Raw references
                                     Store a list of
                                                                                                                                                                                 result in lifetime
                                     players and a list
                                                                                                                                                                                 nightmare
                                     of connections,
                                                                                                                                                                           • Shared ownership
                                     with each                                                          • Easy to index
                                                                                                                                                                                 i.e. Mutex, RwLock
                                     connection having a
                                                                                                                                                                                 needs locking,
                                     reference to a
                                                                                                                                                                                 lots of Results to
                                     player
                                                                                                                                                                                 handle
                                     Store a list of
                                     offline players,
                                     and a list of
                                                                                                                                                                                 Puts a bit more
                                                                                                                                                                           •
                                     online connection,
                                                                                                                                                                                 logic into
                                     on login the player                                                • No references, so
                                                                                                                                                                                 connection and
                                     is moved out of the                                                     no Results
                                                                                                                                                                                 disconnection,
                                     list and into a                                                    • No searches, so no
                                                                                                                                                                                 need to be careful
                                     connection object                                                       Options
                                                                                                                                                                                 not to drop player
                                     which is put into
                                                                                                                                                                                 info
                                     the online
                                     connections list,
                                     undo on disconnect
                                I decided to go with storing a list of offline players and a list of
                                online connections because it didn’t need any error handling so the
                                code would be simpler. At this point I decided to implement that
                                indexed map I talked about earlier, its a wrapper around a HashMap
                                where the keys can be derived from the value, for players that’s
                                their username (I’ll probably replace this with UUIDs at some
                                point), for connections that’s their socket address, here’s the code
                                for the IndexedMap and the Unique trait which I use to implement how
                                to go from the value to the key:
                                    1
                                             trait Unique {
                                    2
                                                 type Key: Eq + PartialEq + Hash;
                                    3
                                    4
                                                 fn get_unique_key(&self) -> Self::Key;
                                    5
                                             }
                                    6
                                    7
                                             struct IndexedMap<T>
                                    8
                                             where
                                    9
                                                 T: Unique,
                                    10
                                             {
                                    11
                                                 inner: HashMap<T::Key, T>,
                                    12
                                             }
                                    13
                                    14
                                             impl<T> IndexedMap<T>
                                    15
                                             where
                                    16
                                                 T: Unique + Clone,
                                    17
                                             {
                                    18
                                                 fn new() -> Self {
                                    19
                                                     Self::default()
                                    20
                                                 }
                                    21
                                    22
                                                 fn get(&self, key: &T::Key) -> Option<&T> {
                                    23
                                                     self.inner.get(key)
                                    24
                                                 }
                                    25
                                    26
                                                 fn get_mut(&mut self, key: &T::Key) -> Option<&mut T> {
                                    27
                                                     self.inner.get_mut(key)
                                    28
                                                 }
                                    29
                                    30
                                                 fn insert(&mut self, value: T) {
                                    31
                                                     self.inner.insert(value.get_unique_key(), value);
                                    32
                                                 }
                                    33
                                    34
                                                 fn remove(&mut self, key: &T::Key) {
                                    35
                                                     self.inner.remove(key);
                                    36
                                                 }
                                    37
                                    38
                                                 fn values<'a>(&'a self) -> Values<'a, T::Key, T> {
                                    39
                                                     self.inner.values()
                                    40
                                                 }
                                    41
                                    42
                                                 fn keys<'a>(&'a self) -> Keys<'a, T::Key, T> {
                                    43
                                                     self.inner.keys()
                                    44
                                                 }
                                    45
                                    46
                                                 fn take(&mut self, key: &T::Key) -> Option<T> {
                                    47
                                                     let value = self.get(key).cloned();
                                    48
                                                     self.remove(key);
                                    49
                                                     value
                                    50
                                                 }
                                    51
                                             }
                                    52
                                    53
                                             impl<T> Default for IndexedMap<T>
                                    54
                                             where
                                    55
                                                 T: Unique,
                                    56
                                             {
                                    57
                                                 fn default() -> Self {
                                    58
                                                     Self {
                                    59
                                                         inner: HashMap::new(),
                                    60
                                                     }
                                    61
                                                 }
                                    62
                                             }
                                With the IndexedMap implemented I moved onto updating the Player,
                                Connection and Server structs to fit the specification above:
                                    1
                                             struct Player {
                                    2
                                                 position: Vec3,
                                    3
                                                 inventory: Inventory
                                    4
                                             }
                                    5
                                    6
                                             struct Connection {
                                    7
                                                 last_heartbeat: Instant,
                                    8
                                                 addr: SocketAddr,
                                    9
                                                 player: Player
                                    10
                                             }
                                    11
                                    12
                                             struct Server {
                                    13
                                                 socket: UdpSocket,
                                    14
                                                 offline: IndexedMap<Player>,
                                    15
                                                 online: IndexedMap<Connection>
                                    16
                                             }
                                For IndexedMap to work with players and connections, they need to
                                implement the Unique trait which I’ve done below:
                                    1
                                             impl Unique for Player {
                                    2
                                                 type Key = String;
                                    3
                                    4
                                                 fn get_unique_key(&self) -> Self::Key {
                                    5
                                                     self.username.clone()
                                    6
                                                 }
                                    7
                                             }
                                    8
                                    9
                                             impl Unique for Connection {
                                    10
                                                 type Key = SocketAddr;
                                    11
                                    12
                                                 fn get_unique_key(&self) -> Self::Key {
                                    13
                                                     self.addr
                                    14
                                                 }
                                    15
                                             }
                                I also implemented Deref and DerefMut for Connection so the Player
                                instance within can be easily accessed:
                                    1
                                             impl Deref for Connection {
                                    2
                                                 type Target = Player;
                                    3
                                    4
                                                 fn deref(&self) -> &Self::Target {
                                    5
                                                     &self.player
                                    6
                                                 }
                                    7
                                             }
                                    8
                                    9
                                             impl DerefMut for Connection {
                                    10
                                                 fn deref_mut(&mut self) -> &mut Self::Target {
                                    11
                                                     &mut self.player
                                    12
                                                 }
                                    13
                                             }
                                Next was to change handle_login to take the player out of the offline
                                map, wrap it in a Connection and insert it into the online map
                                    1
                                             fn handle_login(server: &mut Server, packet: &net::server::Login, addr:
                                             SocketAddr) {
                                    2
                                                 let player = server.offline.take(&packet.username).unwrap_or(Player {
                                    3
                                                     position: Vec3::ZERO,
                                    4
                                                     username: packet.username.clone(),
                                    5
                                                     inventory: Inventory::new()
                                    6
                                                 });
                                    7
                                    8
                                                 server.online.insert(Connection { last_heartbeat: Instant::now(), addr,
                                             player });
                                    9
                                    10
                                                 let connection = server.online.get(&addr).expect("Failed to get connection
                                             that was just inserted, this is very bad");
                                    11
                                    12
                                                 ...
                                and then do the opposite when the client disconnects:
                                    1
                                             fn disconnect(server: &mut Server, addr: SocketAddr, reason: Option<String>) -
                                             > Result<()> {
                                    2
                                                 let Some(connection) = server.online
                                    3
                                                     .get(&addr) else {
                                    4
                                                         warn!("Cannot find client for addr {}", addr);
                                    5
                                                         return Err(std::io::Error::new(std::io::ErrorKind::NotFound,
                                             "Client not found").into());
                                    6
                                                     };
                                    7
                                                 info!("{} is disconnecting", connection.player.username);
                                    8
                                    9
                                                 ... // Peers are notified, if it was a forced disconnection, reason is
                                             sent to the client
                                    10
                                    11
                                                 server.offline.insert(connection.player.clone());
                                    12
                                                 server.online.remove(&connection.get_unique_key());
                                    13
                                             }
                                At this point the server was running and I did some testing, I
                                logged on, harvested some trees, login out and back in again and my
                                items didn’t reappear, but in the server logs my items were found
                                from my previous session, I wasn’t setting the client’s inventory
                                when they logged in. I repurposed the ModifyInventory packet and
                                made it common to both the server and client protocols, then on the
                                server I needed to send a ModifyInventory packet for every item
                                stack in that player’s inventory, and on the client I needed to
                                handle these packets by setting those item stacks to the inventory.
                                    1
                                             fn handle_login(server: &mut Server, packet: &net::server::Login, addr:
                                             SocketAddr) {
                                    2
                                                 ... // Login and insert connection
                                    3
                                    4
                                                 for stack in connection.player.inventory.get_items() {
                                    5
                                                     let packet =
                                    6
                                                         net::client::Packet::ModifyInventory(net::client::ModifyInventory
                                             { stack: *stack });
                                    7
                                    8
                                                     if let Err(e) = server.send(connection, &packet) {
                                    9
                                                         warn!(
                                    10
                                                             "Failed to update player {}'s inventory stack {:?} due to {}",
                                    11
                                                             connection.player.username, stack, e
                                    12
                                                         );
                                    13
                                                         continue;
                                    14
                                                     }
                                    15
                                    16
                                                     info!(
                                    17
                                                         "Updating player {}'s stack {:?}",
                                    18
                                                         connection.player.username, stack
                                    19
                                                     );
                                    20
                                                 }
                                    21
                                             }
                                and the client-side is as simple as calling Inventory::set in the
                                network handling function:
                                    1
                                           ...
                                    2
                                    3
                                           net::client::Packet::ModifyInventory(packet) => {
                                    4
                                               info!("Setting {:?} to {}", packet.stack.item, packet.stack.amount);
                                    5
                                               inventory.set(packet.stack);
                                    6
                                           }
                                    7
                                    8
                                           ...
                                And with that I did another round of testing, this was a big server
                                refactor, so I did a full networking test trying to break the server
                                by making it handle lots of clients at once, and everything passed.
                                Inventories were persisting through sessions, and were being updated
                                nearly instantly on login. With this set of features done I did a
                                round of testing with my friends over the internet, to test latency
                                and different computers, and also to gather some feedback before
                                deciding what to implement next.
                                                                                                                                                                            2
                                                                                                                                                                        
                                                                                                        
                                                                                                                                                                                     )
                                                                                                                                                                 (
                                                                                                   (−1)
                                                                                            ∞
                                                                                                                                                       
                                                                                                                                                                      2         2
                                                                                                                                                              dx
                                                                                                                                                      
                                                                                                                                                                   sin   +cos 
                                                                                        ∑
                                                                                                    +1
                                                                                            =0
                                                                                                                                              1
                                                                                                                   (
                                                                                   ∫                                    lim (1+
                                                                                                                                                         )
                                                                                                                                                  )
                                                                                                                                                
                                                                                                        √
                                                                                                √
                                                                                                                       →∞
                                                                                                                                             
                                                                                          ∞
                                                                                      ∑            − +1
                                                                                          =0
